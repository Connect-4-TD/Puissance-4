import numpy as np
import pygame
import sys
import pickle
import random
import time

# Définition des couleurs
Bleu = (0, 0, 255)
Noir = (0, 0, 0)
Rouge = (255, 0, 0)
Jaune = (255, 255, 0)
Blanc = (255, 255, 255)
Gris = (128, 128, 128)
Vert = (0, 200, 0)

# Définition des constantes du jeu
NB_LIGNES = 6  
NB_COLONNES = 7
DIMENSION_CASE = 100  
TAILLE_PION = int(DIMENSION_CASE / 2 - 5)  

# Dimensions de la fenêtre
largeur_fenetre = NB_COLONNES * DIMENSION_CASE
hauteur_fenetre = (NB_LIGNES + 1) * DIMENSION_CASE
dimensions = (largeur_fenetre, hauteur_fenetre)

# Fonction pour initialiser la grille de jeu
def initialiser_grille():
    return np.zeros((NB_LIGNES, NB_COLONNES))

# Déposer un jeton dans la grille
def deposer_jeton(grille, ligne, colonne, num_joueur):
    grille[ligne][colonne] = num_joueur

# Vérifier si une colonne est disponible
def colonne_disponible(grille, colonne):
    return grille[NB_LIGNES - 1][colonne] == 0

# Trouver la première ligne vide dans une colonne
def obtenir_ligne_disponible(grille, colonne):
    for ligne in range(NB_LIGNES):
        if grille[ligne][colonne] == 0:
            return ligne
    return None

# Afficher la grille dans la console (pour debug)
def afficher_grille_console(grille):
    print(np.flip(grille, 0))

def detecter_victoire(grille, jeton):
    # Vérification horizontale
    for col in range(NB_COLONNES - 3):
        for lig in range(NB_LIGNES):
            if (grille[lig][col] == jeton and 
                grille[lig][col+1] == jeton and 
                grille[lig][col+2] == jeton and 
                grille[lig][col+3] == jeton):
                return True

    # Vérification verticale
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES - 3):
            if (grille[lig][col] == jeton and 
                grille[lig+1][col] == jeton and 
                grille[lig+2][col] == jeton and 
                grille[lig+3][col] == jeton):
                return True

    # Vérification diagonale de bas en haut
    for col in range(NB_COLONNES - 3):
        for lig in range(NB_LIGNES - 3):
            if (grille[lig][col] == jeton and 
                grille[lig+1][col+1] == jeton and 
                grille[lig+2][col+2] == jeton and 
                grille[lig+3][col+3] == jeton):
                return True

    # Vérification diagonale de haut en bas
    for col in range(NB_COLONNES - 3):
        for lig in range(3, NB_LIGNES):
            if (grille[lig][col] == jeton and 
                grille[lig-1][col+1] == jeton and 
                grille[lig-2][col+2] == jeton and 
                grille[lig-3][col+3] == jeton):
                return True
    
    return False

def afficher_grille_graphique(grille, surface, pion_anim=None):
    # Effacer l'écran avec un fond noir
    surface.fill(Noir)
    
    # Créer une surface pour le plateau (fond bleu)
    plateau = pygame.Surface((largeur_fenetre, hauteur_fenetre - DIMENSION_CASE))
    plateau.fill(Bleu)
    
    # Dessiner les trous dans le plateau (cercles noirs)
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES):
            centre_x = col * DIMENSION_CASE + DIMENSION_CASE // 2
            centre_y = lig * DIMENSION_CASE + DIMENSION_CASE // 2
            pygame.draw.circle(plateau, Noir, (centre_x, centre_y), TAILLE_PION)
    
    # Placer le plateau sur la surface principale (en dessous de la ligne de prévisualisation)
    surface.blit(plateau, (0, DIMENSION_CASE))
    
    # Dessiner les pions déjà placés
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES):
            if grille[lig][col] != 0:  # S'il y a un pion à cette position
                centre_x = col * DIMENSION_CASE + DIMENSION_CASE // 2
                centre_y = hauteur_fenetre - (lig * DIMENSION_CASE + DIMENSION_CASE // 2)
                
                if grille[lig][col] == 1:  # Joueur 1 (Rouge)
                    pygame.draw.circle(surface, Rouge, (centre_x, centre_y), TAILLE_PION)
                elif grille[lig][col] == 2:  # Joueur 2 (Jaune)
                    pygame.draw.circle(surface, Jaune, (centre_x, centre_y), TAILLE_PION)
    
    # Dessiner le pion en animation (s'il existe)
    if pion_anim:
        pygame.draw.circle(surface, pion_anim['couleur'], 
                         (pion_anim['x'], pion_anim['y']), TAILLE_PION)
    
    pygame.display.update()

def animer_chute(ecran, grille, colonne, couleur_joueur):
    ligne = obtenir_ligne_disponible(grille, colonne)
    if ligne is None:
        return
    
    # Position de départ (en haut de la colonne)
    x = colonne * DIMENSION_CASE + DIMENSION_CASE // 2
    y = DIMENSION_CASE // 2  # Position en haut
    
    # Position finale
    y_final = hauteur_fenetre - (ligne * DIMENSION_CASE + DIMENSION_CASE // 2)
    
    # Variables pour une animation plus physique
    vitesse = 0
    gravite = 1.5
    temps_debut = time.time()
    
    while y < y_final:
        # Effacer la partie supérieure (pour supprimer l'ancien pion d'animation)
        pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, hauteur_fenetre))
        
        # Calculer la nouvelle position avec gravité
        temps_ecoule = time.time() - temps_debut
        vitesse += gravite
        y = min(y + vitesse, y_final)
        
        # Dessiner le pion en animation et la grille
        pion_anim = {'x': x, 'y': y, 'couleur': couleur_joueur}
        afficher_grille_graphique(grille, ecran, pion_anim)
        
        # Petit délai pour l'animation
        pygame.time.delay(16)  # ~60 FPS
        
        # Gérer les événements pour ne pas bloquer le programme
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
                
        # Si on approche de la fin, ralentir un peu pour éviter l'effet de saut
        if y_final - y < 50:
            vitesse *= 0.8

def creer_bouton(surface, texte, position, dimensions, couleur, couleur_texte, police):
    """Crée un bouton avec du texte centré"""
    x, y = position
    largeur, hauteur = dimensions
    
    # Dessiner le rectangle du bouton
    pygame.draw.rect(surface, couleur, (x, y, largeur, hauteur))
    pygame.draw.rect(surface, Noir, (x, y, largeur, hauteur), 2)  # Bordure
    
    # Préparer et positionner le texte
    texte_rendu = police.render(texte, True, couleur_texte)
    texte_rect = texte_rendu.get_rect(center=(x + largeur // 2, y + hauteur // 2))
    surface.blit(texte_rendu, texte_rect)
    
    # Retourner le rectangle pour détecter les clics
    return pygame.Rect(x, y, largeur, hauteur)

def afficher_menu_fin(ecran, gagnant):
    """Affiche le menu de fin de partie avec des options pour rejouer, retourner au menu principal ou quitter"""
    # Tailles et positions
    largeur_bouton = 300
    hauteur_bouton = 60
    espacement = 20
    
    # Polices
    police_titre = pygame.font.SysFont("Arial", 48, bold=True)
    police_bouton = pygame.font.SysFont("Arial", 30)
    
    # Couleur du texte selon le gagnant
    couleur_gagnant = Rouge if gagnant == 1 else Jaune
    
    # Créer une surface semi-transparente pour assombrir l'arrière-plan
    overlay = pygame.Surface((largeur_fenetre, hauteur_fenetre))
    overlay.set_alpha(200)  # Transparence (0-255)
    overlay.fill(Noir)
    ecran.blit(overlay, (0, 0))
    
    # Afficher le texte du gagnant
    message = "Le Rouge gagne!" if gagnant == 1 else "Le Jaune gagne!"
    texte_gagnant = police_titre.render(message, True, couleur_gagnant)
    rect_titre = texte_gagnant.get_rect(center=(largeur_fenetre // 2, 100))
    ecran.blit(texte_gagnant, rect_titre)
    
    # Créer les boutons
    centre_x = largeur_fenetre // 2 - largeur_bouton // 2
    y_actuel = 200
    
    bouton_rejouer = creer_bouton(ecran, "Rejouer", 
                               (centre_x, y_actuel), 
                               (largeur_bouton, hauteur_bouton), 
                               Vert, Blanc, police_bouton)
    
    y_actuel += hauteur_bouton + espacement
    bouton_menu = creer_bouton(ecran, "Menu Principal", 
                           (centre_x, y_actuel), 
                           (largeur_bouton, hauteur_bouton), 
                           Bleu, Blanc, police_bouton)
    
    y_actuel += hauteur_bouton + espacement
    bouton_quitter = creer_bouton(ecran, "Quitter", 
                               (centre_x, y_actuel), 
                               (largeur_bouton, hauteur_bouton), 
                               Rouge, Blanc, police_bouton)
    
    pygame.display.update()
    
    # Attendre une action de l'utilisateur
    while True:
        for evenement in pygame.event.get():
            if evenement.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
                
            if evenement.type == pygame.MOUSEBUTTONDOWN:
                position_souris = pygame.mouse.get_pos()
                
                if bouton_rejouer.collidepoint(position_souris):
                    return "rejouer"
                    
                elif bouton_menu.collidepoint(position_souris):
                    return "menu"
                    
                elif bouton_quitter.collidepoint(position_souris):
                    pygame.quit()
                    sys.exit()

def menu_principal():
    """Affiche le menu principal du jeu"""
    pygame.init()
    ecran = pygame.display.set_mode(dimensions)
    pygame.display.set_caption('Puissance 4 TD-02')
    
    # Polices
    police_titre = pygame.font.SysFont("Arial", 60, bold=True)
    police_bouton = pygame.font.SysFont("Arial", 36)
    
    # Tailles et positions
    largeur_bouton = 300
    hauteur_bouton = 80
    espacement = 40
    
    # Boucle du menu principal
    while True:
        ecran.fill(Noir)
        
        # Titre
        titre = police_titre.render("PUISSANCE 4", True, Blanc)
        rect_titre = titre.get_rect(center=(largeur_fenetre // 2, 120))
        ecran.blit(titre, rect_titre)
        
        # Créer les boutons
        centre_x = largeur_fenetre // 2 - largeur_bouton // 2
        y_actuel = 250
        
        bouton_jouer = creer_bouton(ecran, "Jouer", 
                                 (centre_x, y_actuel), 
                                 (largeur_bouton, hauteur_bouton), 
                                 Vert, Blanc, police_bouton)
        
        y_actuel += hauteur_bouton + espacement
        bouton_charger = creer_bouton(ecran, "Charger Partie", 
                                   (centre_x, y_actuel), 
                                   (largeur_bouton, hauteur_bouton), 
                                   Bleu, Blanc, police_bouton)
        
        y_actuel += hauteur_bouton + espacement
        bouton_quitter = creer_bouton(ecran, "Quitter", 
                                   (centre_x, y_actuel), 
                                   (largeur_bouton, hauteur_bouton), 
                                   Rouge, Blanc, police_bouton)
        
        pygame.display.update()
        
        # Gérer les événements
        for evenement in pygame.event.get():
            if evenement.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
                
            if evenement.type == pygame.MOUSEBUTTONDOWN:
                position_souris = pygame.mouse.get_pos()
                
                if bouton_jouer.collidepoint(position_souris):
                    return "jouer", ecran
                    
                elif bouton_charger.collidepoint(position_souris):
                    grille, joueur_actuel, coups_joues = charger_partie()
                    return "charger", ecran, grille, joueur_actuel, coups_joues
                    
                elif bouton_quitter.collidepoint(position_souris):
                    pygame.quit()
                    sys.exit()

def demarrer_jeu(ecran=None, grille_chargee=None, joueur_chargee=None, coups_joues_charges=None):
    # Initialisation
    if grille_chargee is not None:
        grille = grille_chargee
        joueur_actuel = joueur_chargee
        coups_joues = coups_joues_charges
    else:
        grille = initialiser_grille()
        joueur_actuel = random.randint(0, 1)  # Choix aléatoire entre 0 (Joueur 1) et 1 (Joueur 2)
        coups_joues = []

    position_souris_x = largeur_fenetre // 2  # Position initiale de la souris
    fin_partie = False
    gagnant = None

    # Configuration de Pygame
    if ecran is None:
        pygame.init()
        ecran = pygame.display.set_mode(dimensions)
        pygame.display.set_caption('Puissance 4 TD-02')
    
    police_texte = pygame.font.SysFont("monospace", 75)

    afficher_grille_graphique(grille, ecran)

    # Boucle principale du jeu
    while not fin_partie:
        for evenement in pygame.event.get():
            if evenement.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            # Gestion du survol de souris
            if evenement.type == pygame.MOUSEMOTION:
                position_souris_x = evenement.pos[0]  # Mettre à jour la position de la souris
                couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                
                # Redessiner la partie supérieure avec le pion de prévisualisation
                pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                pygame.draw.circle(ecran, couleur_joueur, 
                                 (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                pygame.display.update(pygame.Rect(0, 0, largeur_fenetre, DIMENSION_CASE))

            # Gestion des clics
            if evenement.type == pygame.MOUSEBUTTONDOWN:
                colonne = evenement.pos[0] // DIMENSION_CASE
                if 0 <= colonne < NB_COLONNES and colonne_disponible(grille, colonne):
                    ligne = obtenir_ligne_disponible(grille, colonne)
                    num_joueur = joueur_actuel + 1
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    
                    # Animation de chute
                    animer_chute(ecran, grille, colonne, couleur_joueur)
                    
                    # Déposer le jeton après l'animation
                    deposer_jeton(grille, ligne, colonne, num_joueur)
                    coups_joues.append((ligne, colonne))

                    # Vérifier s'il y a une victoire
                    if detecter_victoire(grille, num_joueur):
                        gagnant = num_joueur
                        fin_partie = True
                        break  # Sortir de la boucle des événements pour aller au menu de fin

                    afficher_grille_console(grille)  # Pour debug
                    afficher_grille_graphique(grille, ecran)
                    
                    # Changement de joueur
                    joueur_actuel = (joueur_actuel + 1) % 2
                    
                    # Mise à jour immédiate du pion en attente
                    pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    pygame.draw.circle(ecran, couleur_joueur, 
                                     (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                    pygame.display.update(pygame.Rect(0, 0, largeur_fenetre, DIMENSION_CASE))

            # Gestion des touches
            if evenement.type == pygame.KEYDOWN:
                # Annuler le dernier coup (Z)
                if evenement.key == pygame.K_z:
                    if annuler_dernier_coup(grille, coups_joues):
                        joueur_actuel = (joueur_actuel - 1) % 2
                        afficher_grille_console(grille)
                        afficher_grille_graphique(grille, ecran)
                        # Mise à jour du pion en attente après annulation
                        pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                        couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                        pygame.draw.circle(ecran, couleur_joueur, 
                                         (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                        pygame.display.update()

                # Sauvegarder la partie (S)
                elif evenement.key == pygame.K_s:
                    sauvegarder_partie(grille, joueur_actuel, coups_joues)

                # Charger la partie (C)
                elif evenement.key == pygame.K_c:
                    grille, joueur_actuel, coups_joues = charger_partie()
                    afficher_grille_console(grille)
                    afficher_grille_graphique(grille, ecran)
                    # Mise à jour du pion en attente après chargement
                    pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    pygame.draw.circle(ecran, couleur_joueur, 
                                     (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                    pygame.display.update()
                    
    # Si on sort de la boucle, c'est qu'il y a eu une victoire
    if gagnant:
        # Afficher le menu de fin et gérer le choix de l'utilisateur
        choix = afficher_menu_fin(ecran, gagnant)
        
        if choix == "rejouer":
            return demarrer_jeu(ecran)
        elif choix == "menu":
            return menu_principal()
        # Si "quitter", la fonction afficher_menu_fin a déjà géré la sortie

def sauvegarder_partie(grille, joueur_actuel, coups_joues, fichier="sauvegarde.pkl"):
    with open(fichier, "wb") as f:
        pickle.dump((grille, joueur_actuel, coups_joues), f)

def charger_partie(fichier="sauvegarde.pkl"):
    try:
        with open(fichier, "rb") as f:
            grille, joueur_actuel, coups_joues = pickle.load(f)
        return grille, joueur_actuel, coups_joues
    except FileNotFoundError:
        print("Fichier de sauvegarde non trouvé, démarrage d'une nouvelle partie.")
        return initialiser_grille(), random.randint(0, 1), []

def annuler_dernier_coup(grille, coups_joues):
    if not coups_joues:
        return False
    ligne, colonne = coups_joues.pop()
    grille[ligne][colonne] = 0
    return True

def main():
    # Démarrer avec le menu principal
    resultat = menu_principal()
    
    if resultat[0] == "jouer":
        ecran = resultat[1]
        demarrer_jeu(ecran)
    elif resultat[0] == "charger":
        ecran = resultat[1]
        grille = resultat[2]
        joueur_actuel = resultat[3]
        coups_joues = resultat[4]
        demarrer_jeu(ecran, grille, joueur_actuel, coups_joues)

if __name__ == "__main__":
    main()
