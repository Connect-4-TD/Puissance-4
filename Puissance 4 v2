import numpy as np
import pygame
import sys
import pickle
import random
import time

# Définition des couleurs
Bleu = (0, 0, 255)
Noir = (0, 0, 0)
Rouge = (255, 0, 0)
Jaune = (255, 255, 0)
Blanc = (255, 255, 255)

# Définition des constantes du jeu
NB_LIGNES = 6  
NB_COLONNES = 7
DIMENSION_CASE = 100  
TAILLE_PION = int(DIMENSION_CASE / 2 - 5)  

# Dimensions de la fenêtre
largeur_fenetre = NB_COLONNES * DIMENSION_CASE
hauteur_fenetre = (NB_LIGNES + 1) * DIMENSION_CASE
dimensions = (largeur_fenetre, hauteur_fenetre)

# Fonction pour initialiser la grille de jeu
def initialiser_grille():
    return np.zeros((NB_LIGNES, NB_COLONNES))

# Déposer un jeton dans la grille
def deposer_jeton(grille, ligne, colonne, num_joueur):
    grille[ligne][colonne] = num_joueur

# Vérifier si une colonne est disponible
def colonne_disponible(grille, colonne):
    return grille[NB_LIGNES - 1][colonne] == 0

# Trouver la première ligne vide dans une colonne
def obtenir_ligne_disponible(grille, colonne):
    for ligne in range(NB_LIGNES):
        if grille[ligne][colonne] == 0:
            return ligne
    return None

# Afficher la grille dans la console (pour debug)
def afficher_grille_console(grille):
    print(np.flip(grille, 0))

def detecter_victoire(grille, jeton):
    # Vérification horizontale
    for col in range(NB_COLONNES - 3):
        for lig in range(NB_LIGNES):
            if (grille[lig][col] == jeton and 
                grille[lig][col+1] == jeton and 
                grille[lig][col+2] == jeton and 
                grille[lig][col+3] == jeton):
                return True

    # Vérification verticale
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES - 3):
            if (grille[lig][col] == jeton and 
                grille[lig+1][col] == jeton and 
                grille[lig+2][col] == jeton and 
                grille[lig+3][col] == jeton):
                return True

    # Vérification diagonale de bas en haut
    for col in range(NB_COLONNES - 3):
        for lig in range(NB_LIGNES - 3):
            if (grille[lig][col] == jeton and 
                grille[lig+1][col+1] == jeton and 
                grille[lig+2][col+2] == jeton and 
                grille[lig+3][col+3] == jeton):
                return True

    # Vérification diagonale de haut en bas
    for col in range(NB_COLONNES - 3):
        for lig in range(3, NB_LIGNES):
            if (grille[lig][col] == jeton and 
                grille[lig-1][col+1] == jeton and 
                grille[lig-2][col+2] == jeton and 
                grille[lig-3][col+3] == jeton):
                return True
    
    return False

def afficher_grille_graphique(grille, surface, pion_anim=None):
    # Effacer l'écran avec un fond noir
    surface.fill(Noir)
    
    # Créer une surface pour le plateau (fond bleu)
    plateau = pygame.Surface((largeur_fenetre, hauteur_fenetre - DIMENSION_CASE))
    plateau.fill(Bleu)
    
    # Dessiner les trous dans le plateau (cercles noirs)
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES):
            centre_x = col * DIMENSION_CASE + DIMENSION_CASE // 2
            centre_y = lig * DIMENSION_CASE + DIMENSION_CASE // 2
            pygame.draw.circle(plateau, Noir, (centre_x, centre_y), TAILLE_PION)
    
    # Placer le plateau sur la surface principale (en dessous de la ligne de prévisualisation)
    surface.blit(plateau, (0, DIMENSION_CASE))
    
    # Dessiner les pions déjà placés
    for col in range(NB_COLONNES):
        for lig in range(NB_LIGNES):
            if grille[lig][col] != 0:  # S'il y a un pion à cette position
                centre_x = col * DIMENSION_CASE + DIMENSION_CASE // 2
                centre_y = hauteur_fenetre - (lig * DIMENSION_CASE + DIMENSION_CASE // 2)
                
                if grille[lig][col] == 1:  # Joueur 1 (Rouge)
                    pygame.draw.circle(surface, Rouge, (centre_x, centre_y), TAILLE_PION)
                elif grille[lig][col] == 2:  # Joueur 2 (Jaune)
                    pygame.draw.circle(surface, Jaune, (centre_x, centre_y), TAILLE_PION)
    
    # Dessiner le pion en animation (s'il existe)
    if pion_anim:
        pygame.draw.circle(surface, pion_anim['couleur'], 
                         (pion_anim['x'], pion_anim['y']), TAILLE_PION)
    
    pygame.display.update()

def animer_chute(ecran, grille, colonne, couleur_joueur):
    ligne = obtenir_ligne_disponible(grille, colonne)
    if ligne is None:
        return
    
    # Position de départ (en haut de la colonne)
    x = colonne * DIMENSION_CASE + DIMENSION_CASE // 2
    y = DIMENSION_CASE // 2  # Position en haut
    
    # Position finale
    y_final = hauteur_fenetre - (ligne * DIMENSION_CASE + DIMENSION_CASE // 2)
    
    # Variables pour une animation plus physique
    vitesse = 0
    gravite = 1.5
    temps_debut = time.time()
    
    while y < y_final:
        # Effacer la partie supérieure (pour supprimer l'ancien pion d'animation)
        pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, hauteur_fenetre))
        
        # Calculer la nouvelle position avec gravité
        temps_ecoule = time.time() - temps_debut
        vitesse += gravite
        y = min(y + vitesse, y_final)
        
        # Dessiner le pion en animation et la grille
        pion_anim = {'x': x, 'y': y, 'couleur': couleur_joueur}
        afficher_grille_graphique(grille, ecran, pion_anim)
        
        # Petit délai pour l'animation
        pygame.time.delay(16)  # ~60 FPS
        
        # Gérer les événements pour ne pas bloquer le programme
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
                
        # Si on approche de la fin, ralentir un peu pour éviter l'effet de saut
        if y_final - y < 50:
            vitesse *= 0.8

def demarrer_jeu():
    # Initialisation
    grille = initialiser_grille()
    fin_partie = False
    joueur_actuel = random.randint(0, 1)  # Choix aléatoire entre 0 (Joueur 1) et 1 (Joueur 2)
    coups_joues = []
    position_souris_x = largeur_fenetre // 2  # Position initiale de la souris

    # Configuration de Pygame
    pygame.init()
    ecran = pygame.display.set_mode(dimensions)
    pygame.display.set_caption('Puissance 4 TD-02')
    police_texte = pygame.font.SysFont("monospace", 75)

    afficher_grille_graphique(grille, ecran)

    # Boucle principale du jeu
    while not fin_partie:
        for evenement in pygame.event.get():
            if evenement.type == pygame.QUIT:
                sys.exit()

            # Gestion du survol de souris
            if evenement.type == pygame.MOUSEMOTION:
                position_souris_x = evenement.pos[0]  # Mettre à jour la position de la souris
                couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                
                # Redessiner la partie supérieure avec le pion de prévisualisation
                pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                pygame.draw.circle(ecran, couleur_joueur, 
                                 (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                pygame.display.update(pygame.Rect(0, 0, largeur_fenetre, DIMENSION_CASE))

            # Gestion des clics
            if evenement.type == pygame.MOUSEBUTTONDOWN:
                colonne = evenement.pos[0] // DIMENSION_CASE
                if 0 <= colonne < NB_COLONNES and colonne_disponible(grille, colonne):
                    ligne = obtenir_ligne_disponible(grille, colonne)
                    num_joueur = joueur_actuel + 1
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    
                    # Animation de chute
                    animer_chute(ecran, grille, colonne, couleur_joueur)
                    
                    # Déposer le jeton après l'animation
                    deposer_jeton(grille, ligne, colonne, num_joueur)
                    coups_joues.append((ligne, colonne))

                    # Vérifier s'il y a une victoire
                    if detecter_victoire(grille, num_joueur):
                        message = "Le Rouge gagne!" if num_joueur == 1 else "Le Jaune gagne!"
                        couleur = Rouge if num_joueur == 1 else Jaune
                        texte = police_texte.render(message, 1, couleur)
                        ecran.blit(texte, (40, 10))
                        pygame.display.update()
                        fin_partie = True

                    afficher_grille_console(grille)  # Pour debug
                    afficher_grille_graphique(grille, ecran)
                    
                    # Changement de joueur
                    joueur_actuel = (joueur_actuel + 1) % 2
                    
                    # Mise à jour immédiate du pion en attente
                    pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    pygame.draw.circle(ecran, couleur_joueur, 
                                     (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                    pygame.display.update(pygame.Rect(0, 0, largeur_fenetre, DIMENSION_CASE))

                if fin_partie:
                    pygame.time.wait(3000)

            # Gestion des touches
            if evenement.type == pygame.KEYDOWN:
                # Annuler le dernier coup (Z)
                if evenement.key == pygame.K_z:
                    if annuler_dernier_coup(grille, coups_joues):
                        joueur_actuel = (joueur_actuel - 1) % 2
                        afficher_grille_console(grille)
                        afficher_grille_graphique(grille, ecran)
                        # Mise à jour du pion en attente après annulation
                        pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                        couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                        pygame.draw.circle(ecran, couleur_joueur, 
                                         (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                        pygame.display.update()

                # Sauvegarder la partie (S)
                elif evenement.key == pygame.K_s:
                    sauvegarder_partie(grille, joueur_actuel, coups_joues)

                # Charger la partie (C)
                elif evenement.key == pygame.K_c:
                    grille, joueur_actuel, coups_joues = charger_partie()
                    afficher_grille_console(grille)
                    afficher_grille_graphique(grille, ecran)
                    # Mise à jour du pion en attente après chargement
                    pygame.draw.rect(ecran, Noir, (0, 0, largeur_fenetre, DIMENSION_CASE))
                    couleur_joueur = Rouge if joueur_actuel == 0 else Jaune
                    pygame.draw.circle(ecran, couleur_joueur, 
                                     (position_souris_x, DIMENSION_CASE // 2), TAILLE_PION)
                    pygame.display.update()

def sauvegarder_partie(grille, joueur_actuel, coups_joues, fichier="sauvegarde.pkl"):
    with open(fichier, "wb") as f:
        pickle.dump((grille, joueur_actuel, coups_joues), f)

def charger_partie(fichier="sauvegarde.pkl"):
    try:
        with open(fichier, "rb") as f:
            grille, joueur_actuel, coups_joues = pickle.load(f)
        return grille, joueur_actuel, coups_joues
    except FileNotFoundError:
        print("Fichier de sauvegarde non trouvé, démarrage d'une nouvelle partie.")
        return initialiser_grille(), random.randint(0, 1), []

def annuler_dernier_coup(grille, coups_joues):
    if not coups_joues:
        return False
    ligne, colonne = coups_joues.pop()
    grille[ligne][colonne] = 0
    return True

if __name__ == "__main__":
    demarrer_jeu()
